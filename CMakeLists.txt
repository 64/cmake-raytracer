cmake_minimum_required(VERSION 3.10)

set(scale "100000000")
string(LENGTH ${scale} frac_digits)
math(EXPR frac_digits "${frac_digits} - 1")

set(image_width "256")
set(image_height "256")

math(EXPR image_max_x "${image_width} - 1")
math(EXPR image_max_y "${image_height} - 1")

function(add a b res)
    math(EXPR tmp "(${a}) + (${b})")
    set("${res}" "${tmp}" PARENT_SCOPE)
endfunction()

function(sub a b res)
    math(EXPR tmp "(${a}) - (${b})")
    set("${res}" "${tmp}" PARENT_SCOPE)
endfunction()

function(mul a b res)
    # TODO: Can this be made to overflow less?
    math(EXPR tmp "((${a}) * (${b})) / ${scale}")
    set("${res}" "${tmp}" PARENT_SCOPE)
endfunction()

function(div rem div res)
    set(quo 0)
    math(EXPR b "${frac_digits} + 1")
    while((NOT ("${rem}" EQUAL "0")) AND ("${b}" GREATER_EQUAL "0"))
        math(EXPR d "${rem} / ${div}")
        math(EXPR rem "${rem} % ${div}")
        string(REPEAT "0" "${b}" zeroes)
        math(EXPR quo "${quo} + (${d} * 1${zeroes})") # quo += d * pow(10, b)
        set(rem "${rem}0")
        math(EXPR b "${b} - 1")
    endwhile()

    if(${quo} EQUAL 0)
        set("${res}" "${quo}" PARENT_SCOPE)
        return()
    endif()

    # Divide the quotient by 10 (remove the last digit)
    div_by_10(${quo} quo)
    set("${res}" "${quo}" PARENT_SCOPE)
endfunction()

# TODO: Is a regex quicker here?
function(div_by_10 x res)
    string(LENGTH ${x} len)
    math(EXPR len "${len} - 1")
    string(SUBSTRING ${x} 0 "${len}" tmp)
    set("${res}" "${tmp}" PARENT_SCOPE)
endfunction()

function(div_by_2 x res)
    math(EXPR tmp "${x} >> 1")
    set("${res}" "${tmp}" PARENT_SCOPE)
endfunction()

function(mul_by_2 x res)
    math(EXPR tmp "${x} << 1")
    set("${res}" "${tmp}" PARENT_SCOPE)
endfunction()

function(truncate x res)
    math(EXPR tmp "${x} / ${scale}")
    set("${res}" "${tmp}" PARENT_SCOPE)
endfunction()

function(sqrt x res)
    if(${x} LESS 0)
        message(FATAL_ERROR "arg passed to square root ${x} was negative")
    endif()
    
    div_by_2(${x} guess)

    foreach(counter RANGE 3)
        div(${x} ${guess} tmp)
        add(${tmp} ${guess} tmp)
        div_by_2(${tmp} guess)
    endforeach()

    set("${res}" "${guess}" PARENT_SCOPE)
endfunction()

function(rsqrt x res)
    if(${x} LESS 0)
        message(FATAL_ERROR "arg to inverse square root ${x} was negative")
    endif()
    
    to_fp(1.5 three_halves)
    div_by_2(${x} x2)
    div(${scale} ${x} guess) # guess = 1/x

    foreach(counter RANGE 4)
        mul(${guess} ${guess} tmp)
        mul(${tmp} ${x2} tmp)
        sub(${three_halves} ${tmp} tmp)
        mul(${tmp} ${guess} guess)
    endforeach()

    set("${res}" "${guess}" PARENT_SCOPE)
endfunction()

function(vec3_add x y res)
    list(GET ${x} 0 x_0)
    list(GET ${x} 1 x_1)
    list(GET ${x} 2 x_2)
    list(GET ${y} 0 y_0)
    list(GET ${y} 1 y_1)
    list(GET ${y} 2 y_2)
    add(${x_0} ${y_0} z_0)
    add(${x_1} ${y_1} z_1)
    add(${x_2} ${y_2} z_2)
    set("${res}" ${z_0} ${z_1} ${z_2} PARENT_SCOPE)
endfunction()

function(vec3_sub x y res)
    list(GET ${x} 0 x_0)
    list(GET ${x} 1 x_1)
    list(GET ${x} 2 x_2)
    list(GET ${y} 0 y_0)
    list(GET ${y} 1 y_1)
    list(GET ${y} 2 y_2)
    sub(${x_0} ${y_0} z_0)
    sub(${x_1} ${y_1} z_1)
    sub(${x_2} ${y_2} z_2)
    set("${res}" ${z_0} ${z_1} ${z_2} PARENT_SCOPE)
endfunction()

function(vec3_mulf x y res)
    list(GET ${x} 0 x_0)
    list(GET ${x} 1 x_1)
    list(GET ${x} 2 x_2)
    mul(${x_0} ${y} z_0)
    mul(${x_1} ${y} z_1)
    mul(${x_2} ${y} z_2)
    set("${res}" ${z_0} ${z_1} ${z_2} PARENT_SCOPE)
endfunction()

function(vec3_divf x y res)
    list(GET ${x} 0 x_0)
    list(GET ${x} 1 x_1)
    list(GET ${x} 2 x_2)
    div(${x_0} ${y} z_0)
    div(${x_1} ${y} z_1)
    div(${x_2} ${y} z_2)
    set("${res}" ${z_0} ${z_1} ${z_2} PARENT_SCOPE)
endfunction()

function(vec3_dot x y res)
    list(GET ${x} 0 x_0)
    list(GET ${x} 1 x_1)
    list(GET ${x} 2 x_2)
    list(GET ${y} 0 y_0)
    list(GET ${y} 1 y_1)
    list(GET ${y} 2 y_2)
    mul(${x_0} ${y_0} z_0)
    mul(${x_1} ${y_1} z_1)
    mul(${x_2} ${y_2} z_2)
    add(${z_0} ${z_1} tmp)
    add(${tmp} ${z_2} tmp)
    set("${res}" ${tmp} PARENT_SCOPE)
endfunction()

#function(vec3_normalize x res)
    #vec3_dot(${x} ${x} x_2)
    #rsqrt(${x_2} one_over_length)
    #vec3_mulf(${x} ${one_over_length} tmp)
    #set("${res}" ${tmp} PARENT_SCOPE)
#endfunction()

function(to_fp x res)
    string(REPLACE "." ";" both_parts "${x};0")
    list(GET both_parts 0 int_part)
    list(GET both_parts 1 frac_part)
    string(SUBSTRING ${int_part} 0 1 sign)
    math(EXPR int_part "${int_part}") # -0 -> 0

    string(SUBSTRING ${frac_part} 0 6 frac_part)
    string(LENGTH ${frac_part} frac_length)
    math(EXPR pad_length "${frac_digits} - ${frac_length}")
    string(REPEAT "0" "${pad_length}" padding)

    if(${sign} STREQUAL "-")
        message(${int_part})
        math(EXPR tmp "${int_part} * ${scale} - ${frac_part}${padding}")
    else()
        math(EXPR tmp "${int_part} * ${scale} + ${frac_part}${padding}")
    endif()

    set("${res}" "${tmp}" PARENT_SCOPE)
endfunction()

function(from_fp x res)
    if(${x} GREATER_EQUAL 0)
        math(EXPR int_part "(${x}) / ${scale}")
        if(${int_part} EQUAL 0)
            math(EXPR x "${x} + ${scale}")
        endif()


        # Can't just do x % scale, because this does not preserve leading zeroes
        string(LENGTH ${x} x_length)
        math(EXPR decimal_point_pos "${x_length} - ${frac_digits}")
        string(SUBSTRING "${x}" ${decimal_point_pos} ${frac_digits} fract_part)
    else()
        math(EXPR int_part "(${x}) / ${scale}")
        if(${int_part} EQUAL 0)
            set(int_part "-0")
            math(EXPR x "${x} - ${scale}")
        endif()

        string(LENGTH ${x} x_length)
        math(EXPR decimal_point_pos "${x_length} - ${frac_digits}")
        string(SUBSTRING "${x}" ${decimal_point_pos} ${frac_digits} fract_part)
    endif()

    set("${res}" "${int_part}.${fract_part}" PARENT_SCOPE)
endfunction()

function(vec3_to_fp x y z res)
    to_fp(${x} x)
    to_fp(${y} y)
    to_fp(${z} z)
    set("${res}" ${x} ${y} ${z} PARENT_SCOPE)
endfunction()

function(vec3_print v)
    list(GET ${v} 0 v_0)
    list(GET ${v} 1 v_1)
    list(GET ${v} 2 v_2)
    from_fp(${v_0} v_0)
    from_fp(${v_1} v_1)
    from_fp(${v_2} v_2)
    message("{ ${v_0}, ${v_1}, ${v_2} }")
endfunction()

function(print x)
    from_fp("${x}" tmp)
    message(${tmp})
endfunction()

function(abs x res)
    if(${x} LESS 0)
        math(EXPR tmp "-${x}")
        set("${res}" "${tmp}" PARENT_SCOPE)
    else()
        set("${res}" "${x}" PARENT_SCOPE)
    endif()
endfunction()

function(sphere_intersect ray_origin ray_dir hit hit_normal)
    to_fp(0.35 radius)
    mul(${radius} ${radius} radius_2)
    vec3_to_fp(0.5 0.5 1 center)

    vec3_sub(${ray_origin} center oc)
    vec3_dot(${ray_dir} ${ray_dir} a)
    vec3_dot(oc ${ray_dir} half_b)
    vec3_dot(oc oc oc_2)
    sub(${oc_2} ${radius_2} c)

    mul(${half_b} ${half_b} half_b_2)
    mul(${a} ${c} ac)
    sub(${half_b_2} ${ac} discrim)

    if(${discrim} GREATER 0)
        sqrt(${discrim} root)
        sub(0 ${half_b} minus_half_b)

        sub(${minus_half_b} ${root} t)
        div(${t} ${a} t)
        if(${t} GREATER 0)
            # p = o + t * d
            vec3_mulf(${ray_dir} ${t} tv)
            vec3_add(${ray_origin} tv point)
            vec3_sub(point center normal)
            vec3_divf(normal ${radius} unit_normal)
            set(${hit_normal} ${unit_normal} PARENT_SCOPE)
            set(${hit} "TRUE" PARENT_SCOPE)
            return()
        endif()

        add(${minus_half_b} ${root} t)
        div(${t} ${a} t)
        if (${t} GREATER 0)
            # p = o + t * d
            vec3_mulf(${ray_dir} ${t} tv)
            vec3_add(${ray_origin} tv point)
            vec3_sub(point center normal)
            vec3_divf(normal ${radius} unit_normal)
            set(${hit_normal} ${unit_normal} PARENT_SCOPE)
            set(${hit} "TRUE" PARENT_SCOPE)
            return()
        endif()
    endif()

    set(${hit} "FALSE" PARENT_SCOPE)
endfunction()

to_fp(255.99 rgb_scaling)
to_fp(0.2 b)
to_fp(${image_width} image_width_fp)
to_fp(${image_height} image_height_fp)

#vec3_to_fp(0.7 0.1 0.1 sphere_color)
to_fp(0.7 sphere_color)

message("P3\n${image_width} ${image_height}\n255")

foreach(y RANGE ${image_max_y})
    set(row "")
    to_fp(${y} y_fp)

    foreach(x RANGE ${image_max_x})
        to_fp(${x} x_fp)

        div(${x_fp} ${image_width_fp} u)
        div(${y_fp} ${image_height_fp} v)

        set(o ${u} ${v} 0)
        set(d 0 0 ${scale})
        sphere_intersect(o d hit normal)
        if(hit)
            # shade according to n dot v
            vec3_dot(d normal cos)
            abs(${cos} abs_cos)
            mul(${abs_cos} ${sphere_color} r)
        else()
            set(r 0)
        endif()

        mul(${r} ${rgb_scaling} r)
        #mul(${g} ${rgb_scaling} g)
        #mul(${b} ${rgb_scaling} b)
        set(g 0)
        set(b 0)

        truncate(${r} r)
        truncate(${g} g)
        truncate(${b} b)

        set(row "${row} ${r} ${g} ${b}")
    endforeach()

    message("${row}")
endforeach()
